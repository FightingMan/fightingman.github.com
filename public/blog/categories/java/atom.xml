<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | FightingMan's FootPrints]]></title>
  <link href="http://FightingMan.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://FightingMan.github.com/"/>
  <updated>2014-04-24T00:53:11+08:00</updated>
  <id>http://FightingMan.github.com/</id>
  <author>
    <name><![CDATA[FightingMan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An Interesting Thing Occurs While a Class Inside Interface]]></title>
    <link href="http://FightingMan.github.com/blog/2012/12/08/an-interesting-thing-occurs-while-a-class-inside-interface/"/>
    <updated>2012-12-08T22:08:00+08:00</updated>
    <id>http://FightingMan.github.com/blog/2012/12/08/an-interesting-thing-occurs-while-a-class-inside-interface</id>
    <content type="html"><![CDATA[<p>While I’m putting class inside interface with anonymous,something interested occurs.
{% codeblock As21.java %}
interface Comm {</p>

<pre><code>class Inner implements Comm {
    static void f(Comm c) {
        c.v();
    }
    public void v() {}
}

public void v();
</code></pre>

<p>}</p>

<p>interface Diff {</p>

<pre><code>class Differ implements Comm {
    static void g(Comm c) {
        c.v();
    }
    public void v() {}
}
</code></pre>

<p>}</p>

<p>public class As21 {</p>

<pre><code>public static void main(String[] args) {
    Comm c = new Comm() {
        public void v() {
            System.out.println("as21");
        }
    };
    Comm.Inner.f(c);
}
</code></pre>

<p>}</p>

<p>class As22 implements Comm {</p>

<pre><code>public void v() {
    System.out.println("as22");
}

public static void main(String[] args) {
    As22 a = new As22();
    Inner.f(a);
    Diff.Differ.g(a);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>As you can see,As21 is the one which I wantted,but the interesting thing occurs in As22. First,any class you put inside an interface is automatically public and static. Then As22 implements the Comm interface so it can call f() method directly with using Inner.f() witout Comm in front of it, but the method f() in Diff interface cannot called directly,must use Diff.differ.f().</p>

<p>In addition,how to execute the program in command line while put classes inside interfaces?</p>

<p>e.g.
{% codeblock As20.java %}
interface As20 {</p>

<pre><code>class Inner implements As20 {
    public String toString() {
        return "test";
    }
    public static void main(String[] args) {
        Inner i = new Inner();
        System.out.println(i);
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<blockquote><p>javac As20.java</p>

<p>java As20\$Inner</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Basic syntax of inner class]]></title>
    <link href="http://FightingMan.github.com/blog/2012/11/27/basic-snytax-of-inner-class/"/>
    <updated>2012-11-27T23:02:00+08:00</updated>
    <id>http://FightingMan.github.com/blog/2012/11/27/basic-snytax-of-inner-class</id>
    <content type="html"><![CDATA[<p>Place a class definition within another class definition that is called an inner class.
{% codeblock Outer.java %}
public class Outer {</p>

<pre><code>private int i = 10;
public void f() {
    System.out.println("outer's f()");
}

private class Inner {
    public Outer outer() { //!cannot with static
        return Outer.this;
    }

    public Outer outer(int i) { //!cannot with static
        return new Outer();
    }

    public void f() {
        System.out.println("inner's f()");
    }

    public Inner() {
        System.out.println(i);
    }
}

public Inner inner() { //!cannot with static
    return new Inner();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<!--more-->


<p>{% codeblock InnerClass.java %}
public class InnerClass {</p>

<pre><code>public static void main(String[] args) {
    //! Outer.Inner in = new Inner();
    //! Outer.Inner in = new Outer.Inner();
    Outer outa = new Outer();
    outa.f();
    Outer.Inner ina = outa.inner();
    Outer.Inner inb = outa.new Inner();
    ina.outer().f();
    inb.outer().f();
    ina.f();
    inb.f();
    Outer outb = ina.outer(1);
    Outer outc = inb.outer(1);
    outb.f();
    outc.f();
    Outer.Inner inc = outb.inner();
    Outer.Inner ind = outb.new Inner();
    Outer.Inner ine = outc.inner();
    Outer.Inner inf = outc.new Inner();
    inc.outer().f();
    ind.outer().f();
    inc.f();
    ind.f();
    ine.outer().f();
    inf.outer().f();
    ine.f();
    inf.f();
}
</code></pre>

<p>}//output:
outer's f()
10
10
outer's f()
outer's f()
inner's f()
inner's f()
outer's f()
outer's f()
10
10
10
10
outer's f()
outer's f()
inner's f()
inner's f()
outer's f()
outer's f()
inner's f()
inner's f()
{% endcodeblock %}
You can make an object of the inner class anywhere except from within a no-static method of the outer class(if u don't use .new). Inner class has access rights to all the elements in the enclosing class.
Notice: If you make a static inner class(called nested class), then it doesn't need a reference to the outer-class object.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nesting interfaces]]></title>
    <link href="http://FightingMan.github.com/blog/2012/11/23/nesting-interfaces/"/>
    <updated>2012-11-23T01:27:00+08:00</updated>
    <id>http://FightingMan.github.com/blog/2012/11/23/nesting-interfaces</id>
    <content type="html"><![CDATA[<p>These features may seem like they are added strictly for syntactic consistency,maybe I will use it sometime :).
There are 5 Rules:</p>

<blockquote><ol>
<li>Nesting an interface within a class,these can have public package-access protected private visibility.</li>
<li>Nesting an interface within an interface they just have public or package-access visibility but all the elements must be public because an interface nested with another interface is automatically public(whether you specify it).</li>
<li>Nesting an interface within a class with any visibility,it can also be implemented any visibility.And if you implements a private interface with any visibility it can only be used as itself.It also means without allowing any upcasting.</li>
<li>The only thing that works is if the return value is handed to an object that has permission to use it.</li>
<li>When you implement an interface, you are not required to implemtns any interface nested within.</li>
</ol>
</blockquote>

<p>Let me show the codes:</p>

<!--more-->


<p>{% codeblock NestingInterfaces.java %}
class A {</p>

<pre><code>interface B {
    void f();
}
public class BImp implements B {
    public void f() {}
}
private class BImp2 implements B {
    public void f() {}
}
public interface C {
    void f();
}
class CImp implements C {
    public void f() {}
}
private class CImp2 implements C {
    public void f() {}
}
private interface D {
    void f();
}
private class DImp implements D {
    public void f() {}
}
public class DImp2 implements D {
    public void f() {}
}
public D getD() { return new DImp2(); }
private D dRef;
public void receiveD(D d) {
    dRef = d;
    dRef.f();
}
</code></pre>

<p>}</p>

<p>interface E {</p>

<pre><code>interface G {
    void f();
}
// Redundant "public":
public interface H {
    void f();
}
void g();
// Cannot be private within an interface:
//! private interface I {}
</code></pre>

<p>}</p>

<p>public class NestingInterfaces {</p>

<pre><code>public class BImp implements A.B {
    public void f() {}
}
class CImp implements A.C {
    public void f() {}
}
// Cannot implement a private interface except
// within that interface’s defining class:
//! class DImp implements A.D {
//! public void f() {}
//! }
class EImp implements E {
    public void g() {}
}
class EGImp implements E.G {
    public void f() {}
}
class EImp2 implements E {
    public void g() {}
}
class EG implements E.G {
    public void f() {}
}

public static void main(String[] args) {
    A a = new A();
    // Can’t access A.D:
    //! A.D ad = a.getD();
    // Doesn’t return anything but A.D:
    //! A.DImp2 di2 = a.getD();
    // Cannot access a member of the interface:
    //! a.getD().f();
    // Only another A can do anything with getD():
    A a2 = new A();
    a2.receiveD(a.getD());
}
</code></pre>

<p>}
 ///:~
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fields in interface]]></title>
    <link href="http://FightingMan.github.com/blog/2012/11/23/fields-in-interface/"/>
    <updated>2012-11-23T01:20:00+08:00</updated>
    <id>http://FightingMan.github.com/blog/2012/11/23/fields-in-interface</id>
    <content type="html"><![CDATA[<p>Fields in interface are automatically static and final,which means the interface is a convenient tool for creating groups of constant value.
Since the fields are static,they are initialized when the class is first loaded,which happens when any of the fields are accessed for the first time.The fields,of course,are not part of the interface.The values are stored in the static storage area for that interface.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Strategy & Factory design pattern with interface]]></title>
    <link href="http://FightingMan.github.com/blog/2012/11/23/strategy-and-factory-design-patter-with-interface/"/>
    <updated>2012-11-23T00:39:00+08:00</updated>
    <id>http://FightingMan.github.com/blog/2012/11/23/strategy-and-factory-design-patter-with-interface</id>
    <content type="html"><![CDATA[<p>Strategy design pattern</p>

<blockquote><p>When you write a method that performs certain operations,and that method takes an interface which you also specify,then the others can use this method with any object,as long as their object conforms to the interface.
{% codeblock RandomWords.java %}
import java.nio.<em>;
import java.util.</em>;
public class RandomWords implements Readable {</p>

<pre><code>private static Random rand = new Random(47);
private static final char[] capitals = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
private static final char[] lowers = "abcdefghijklmnopqrstuvwxyz".toCharArray();
private static final char[] vowels = "aeiou".toCharArray();
private int count;
public RandomWords(int count) {
    this.count = count;
}
public int read(CharBuffer cb) {
    if(count-- == 0) return -1;
    cb.append(capitals[rand.nextInt(capitals.length)]);
    for (int i = 0; i &lt; 4; i++) {
        cb.append(lowers[rand.nextInt(lowers.length)]);
        cb.append(vowels[rand.nextInt(vowels.length)]);
    }
    cb.append("|");
    cb.append(" ");
    return 1;
}
public static void main(String[] args) {
    Scanner s = new Scanner(new RandomWords(10));
    while (s.hasNext()) {
        System.out.println(s.next());
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p></blockquote>

<!--more-->


<p>Factory design pattern</p>

<blockquote><p>Instead of calling a constructor directly, you call a creation method on a factory object which produces an implementation of the interface-this way,in theory,your code is completely isolated from the implementation of the interface,thus making it possible to transparently swap one implementation for another.
{% codeblock Decisions.java %}
import java.util.*;
interface Decision {</p>

<pre><code>void toss();
</code></pre>

<p>}</p></blockquote>

<p>interface DecisionFactory{</p>

<pre><code>Decision getDecision();
</code></pre>

<p>}</p>

<p>class Coin implements Decision {</p>

<pre><code>private static final int point = new Random().nextInt(6)+1;
public void toss() {
    System.out.println("Coin point = " + point);
}
</code></pre>

<p>}</p>

<p>class CoinFactory implements DecisionFactory {</p>

<pre><code>public Decision getDecision() {
    return new Coin();
}
</code></pre>

<p>}</p>

<p>class Dice implements Decision {</p>

<pre><code>private static final String[] s = {"head","flower"};
private static final int point = new Random().nextInt(2);
public void toss() {
    System.out.println("Dice point " + s[point]);
}
</code></pre>

<p>}</p>

<p>class DiceFactory implements DecisionFactory {</p>

<pre><code>public Decision getDecision() {
    return new Dice();
}
</code></pre>

<p>}</p>

<p>public class Decisions {</p>

<pre><code>public static void doToss(DecisionFactory factory) {
    Decision d = factory.getDecision();
    d.toss();
}

public static void main(String[] args) {
    doToss(new CoinFactory());
    doToss(new DiceFactory());
}
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
